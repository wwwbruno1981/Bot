// arquivo .env

# ===========================================
# CONFIGURA√á√ïES DA API BINANCE
# ===========================================
BINANCE_API_KEY=sua_api_key_aqui
BINANCE_API_SECRET=sua_api_secret_aqui
BINANCE_BASE_URL=https://api.binance.com
BINANCE_WS_URL=wss://stream.binance.com:9443/ws

# ===========================================
# CONFIGURA√á√ïES DE TRADING
# ===========================================
TRADING_SYMBOL=BTCUSDT
TRADING_QUANTITY=0.001
TRADING_SHORT_PERIOD=7
TRADING_LONG_PERIOD=21
TRADING_USE_EMA=true
TRADING_MIN_PROFIT=0.5

# ===========================================
# GERENCIAMENTO DE RISCO
# ===========================================
RISK_STOP_LOSS=-2.0
RISK_TAKE_PROFIT=3.0
RISK_TRAILING_STOP=true
RISK_TRAILING_STOP_PERCENT=1.5
RISK_MAX_POSITIONS=1
RISK_MAX_DAILY_LOSS=-5.0
RISK_MAX_DAILY_TRADES=10

# ===========================================
# NOTIFICA√á√ïES TELEGRAM
# ===========================================
TELEGRAM_ENABLED=false
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=

# ===========================================
# CONFIGURA√á√ïES DE LOG
# ===========================================
LOG_LEVEL=info
LOG_SAVE_TO_FILE=true
LOG_MAX_FILE_SIZE=10
LOG_DIRECTORY=./logs

# ===========================================
# CONFIGURA√á√ïES AVAN√áADAS
# ===========================================
MAX_RECONNECT_ATTEMPTS=10
HEARTBEAT_INTERVAL=30000
STATUS_DISPLAY_INTERVAL=60000
PRICE_PRECISION=8
QUANTITY_PRECISION=6

# ===========================================
# MODO DE DESENVOLVIMENTO
# ===========================================
NODE_ENV=production
DEBUG=false
SIMULATE_TRADING=false


// arquivo package.json

{
  "name": "btc-trading-bot",
  "version": "2.0.0",
  "description": "Bot de trading avan√ßado para BTC/USDT na Binance usando estrat√©gia de m√©dias m√≥veis",
  "main": "src/bot.js",
  "scripts": {
    "start": "node src/bot.js",
    "dev": "nodemon src/bot.js",
    "test": "node tests/test.js",
    "simulate": "SIMULATE_TRADING=true node src/bot.js",
    "setup": "node scripts/setup.js",
    "logs": "tail -f logs/trading-bot.log",
    "clean-logs": "rm -rf logs/*.log"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "ws": "^8.14.2",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "chalk": "^4.1.2",
    "moment": "^2.29.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  },
  "keywords": [
    "trading",
    "bitcoin",
    "binance",
    "bot",
    "cryptocurrency",
    "automated-trading",
    "ema",
    "sma",
    "risk-management"
  ],
  "author": "Trading Bot Developer",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/seu-usuario/btc-trading-bot.git"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "engineStrict": true

  // arquivo bot.js

  const axios = require('axios');
const crypto = require('crypto');
const WebSocket = require('ws');
const moment = require('moment');

const ConfigManager = require('./config/ConfigManager');
const Logger = require('./utils/Logger');

class BinanceTradingBot {
    constructor() {
        // Inicializar configura√ß√£o e logger
        this.configManager = new ConfigManager();
        this.config = this.configManager.getConfig();
        this.logger = new Logger(this.config);

        // Estados do bot
        this.prices = [];
        this.shortMA = [];
        this.longMA = [];
        this.position = null;
        this.lastPrice = 0;
        this.entryPrice = 0;
        this.highestPrice = 0;
        this.isInitialized = false;
        this.orderInProgress = false;
        this.reconnectAttempts = 0;
        
        // Controles de risco di√°rio
        this.dailyStats = {
            trades: 0,
            profit: 0,
            startTime: moment().startOf('day')
        };

        // WebSocket reference
        this.ws = null;
        this.statusInterval = null;
        this.heartbeatInterval = null;

        this.init();
    }

    // Assinar requisi√ß√£o para API da Binance
    signRequest(queryString) {
        return crypto
            .createHmac('sha256', this.config.api.apiSecret)
            .update(queryString)
            .digest('hex');
    }

    // Fazer requisi√ß√£o autenticada com retry
    async authenticatedRequest(method, endpoint, params = {}, retries = 3) {
        const timestamp = Date.now();
        const queryString = new URLSearchParams({
            ...params,
            timestamp: timestamp
        }).toString();

        const signature = this.signRequest(queryString);
        const finalQuery = `${queryString}&signature=${signature}`;

        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                const config = {
                    method: method,
                    url: `${this.config.api.baseURL}${endpoint}?${finalQuery}`,
                    headers: {
                        'X-MBX-APIKEY': this.config.api.apiKey
                    },
                    timeout: 10000
                };

                const response = await axios(config);
                return response.data;
            } catch (error) {
                this.logger.warn(`Tentativa ${attempt}/${retries} falhou`, { 
                    endpoint, 
                    error: error.message 
                });

                if (attempt === retries) {
                    this.logger.error('Todas as tentativas de requisi√ß√£o falharam');
                    throw error;
                }

                await this.sleep(1000 * attempt);
            }
        }
    }

    // Fun√ß√£o sleep
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Obter dados hist√≥ricos de pre√ßos
    async getHistoricalData() {
        try {
            const response = await axios.get(`${this.config.api.baseURL}/api/v3/klines`, {
                params: {
                    symbol: this.config.trading.symbol,
                    interval: '1m',
                    limit: Math.max(this.config.trading.longPeriod + 10, 100)
                }
            });

            const prices = response.data.map(candle => parseFloat(candle[4]));
            this.prices = prices;
            this.lastPrice = prices[prices.length - 1];
            this.calculateMovingAverages();
            this.isInitialized = true;

            this.logger.info(`Dados hist√≥ricos carregados`, { 
                symbol: this.config.trading.symbol,
                currentPrice: this.lastPrice,
                dataPoints: prices.length
            });
        } catch (error) {
            this.logger.error('Erro ao obter dados hist√≥ricos', { error: error.message });
            throw error;
        }
    }

    // Calcular m√©dias m√≥veis (SMA ou EMA)
    calculateMovingAverages() {
        if (this.prices.length < this.config.trading.longPeriod) return;

        if (this.config.trading.useEMA) {
            this.calculateEMA();
        } else {
            this.calculateSMA();
        }
    }

    // Calcular EMA
    calculateEMA() {
        const shortAlpha = 2 / (this.config.trading.shortPeriod + 1);
        const longAlpha = 2 / (this.config.trading.longPeriod + 1);
        const currentPrice = this.prices[this.prices.length - 1];

        if (this.shortMA.length === 0) {
            const shortSum = this.prices.slice(-this.config.trading.shortPeriod).reduce((a, b) => a + b, 0);
            this.shortMA.push(shortSum / this.config.trading.shortPeriod);
        } else {
            const prevShortEMA = this.shortMA[this.shortMA.length - 1];
            const newShortEMA = (currentPrice * shortAlpha) + (prevShortEMA * (1 - shortAlpha));
            this.shortMA.push(newShortEMA);
        }

        if (this.longMA.length === 0 && this.prices.length >= this.config.trading.longPeriod) {
            const longSum = this.prices.slice(-this.config.trading.longPeriod).reduce((a, b) => a + b, 0);
            this.longMA.push(longSum / this.config.trading.longPeriod);
        } else if (this.longMA.length > 0) {
            const prevLongEMA = this.longMA[this.longMA.length - 1];
            const newLongEMA = (currentPrice * longAlpha) + (prevLongEMA * (1 - longAlpha));
            this.longMA.push(newLongEMA);
        }

        // Manter apenas √∫ltimos 50 valores
        if (this.shortMA.length > 50) this.shortMA.shift();
        if (this.longMA.length > 50) this.longMA.shift();
    }

    // Calcular SMA
    calculateSMA() {
        const shortSum = this.prices.slice(-this.config.trading.shortPeriod).reduce((a, b) => a + b, 0);
        const shortMA = shortSum / this.config.trading.shortPeriod;
        this.shortMA.push(shortMA);

        const longSum = this.prices.slice(-this.config.trading.longPeriod).reduce((a, b) => a + b, 0);
        const longMA = longSum / this.config.trading.longPeriod;
        this.longMA.push(longMA);

        if (this.shortMA.length > 50) this.shortMA.shift();
        if (this.longMA.length > 50) this.longMA.shift();
    }

    // Verificar sinal de compra/venda
    checkSignal() {
        if (this.shortMA.length < 2 || this.longMA.length < 2) return null;

        const currentShortMA = this.shortMA[this.shortMA.length - 1];
        const currentLongMA = this.longMA[this.longMA.length - 1];
        const prevShortMA = this.shortMA[this.shortMA.length - 2];
        const prevLongMA = this.longMA[this.longMA.length - 2];

        // Cruzamento para cima (sinal de compra)
        if (prevShortMA <= prevLongMA && currentShortMA > currentLongMA) {
            return 'BUY';
        }

        // Cruzamento para baixo (sinal de venda)
        if (prevShortMA >= prevLongMA && currentShortMA < currentLongMA) {
            return 'SELL';
        }

        return null;
    }

    // Verificar controles de risco di√°rio
    checkDailyRiskLimits() {
        // Resetar estat√≠sticas se for um novo dia
        const today = moment().startOf('day');
        if (!today.isSame(this.dailyStats.startTime)) {
            this.dailyStats = {
                trades: 0,
                profit: 0,
                startTime: today
            };
            this.logger.info('Estat√≠sticas di√°rias resetadas');
        }

        // Verificar limite de trades di√°rios
        if (this.dailyStats.trades >= this.config.riskManagement.maxDailyTrades) {
            this.logger.warn('Limite di√°rio de trades atingido', { 
                dailyTrades: this.dailyStats.trades,
                maxTrades: this.config.riskManagement.maxDailyTrades
            });
            return false;
        }

        // Verificar limite de perda di√°ria
        if (this.dailyStats.profit <= this.config.riskManagement.maxDailyLoss) {
            this.logger.warn('Limite di√°rio de perda atingido', { 
                dailyProfit: this.dailyStats.profit,
                maxLoss: this.config.riskManagement.maxDailyLoss
            });
            return false;
        }

        return true;
    }

    // Obter saldo da conta
    async getBalance() {
        try {
            const account = await this.authenticatedRequest('GET', '/api/v3/account');
            const btcBalance = account.balances.find(b => b.asset === this.config.trading.symbol.replace('USDT', ''));
            const usdtBalance = account.balances.find(b => b.asset === 'USDT');

            const balances = {
                BTC: parseFloat(btcBalance?.free || 0),
                USDT: parseFloat(usdtBalance?.free || 0)
            };

            this.logger.balance(balances);
            return balances;
        } catch (error) {
            this.logger.error('Erro ao obter saldo', { error: error.message });
            return { BTC: 0, USDT: 0 };
        }
    }

    // Executar ordem de compra
    async buyOrder() {
        if (this.orderInProgress) {
            this.logger.warn('Ordem j√° em progresso, ignorando nova ordem de compra');
            return false;
        }

        // Verificar limites de risco di√°rio
        if (!this.checkDailyRiskLimits()) {
            return false;
        }

        this.orderInProgress = true;

        try {
            if (!this.isInitialized || this.lastPrice <= 0) {
                this.logger.warn('Bot n√£o inicializado ou pre√ßo inv√°lido para compra');
                return false;
            }

            // Verificar se j√° temos posi√ß√£o m√°xima
            if (this.position && this.config.riskManagement.maxPositions <= 1) {
                this.logger.warn('J√° existe uma posi√ß√£o aberta');
                return false;
            }

            const balance = await this.getBalance();
            const requiredAmount = this.config.trading.quantity * this.lastPrice;

            if (balance.USDT < requiredAmount) {
                this.logger.warn('Saldo insuficiente', { 
                    required: requiredAmount,
                    available: balance.USDT
                });
                return false;
            }

            // Modo simula√ß√£o
            if (this.config.development.simulateTrading) {
                this.logger.info('üéÆ SIMULA√á√ÉO - Ordem de compra executada', {
                    symbol: this.config.trading.symbol,
                    quantity: this.config.trading.quantity,
                    price: this.lastPrice
                });
            } else {
                const order = await this.authenticatedRequest('POST', '/api/v3/order', {
                    symbol: this.config.trading.symbol,
                    side: 'BUY',
                    type: 'MARKET',
                    quantity: this.config.trading.quantity.toFixed(this.config.advanced.quantityPrecision)
                });

                this.logger.trade('BUY', {
                    symbol: this.config.trading.symbol,
                    quantity: this.config.trading.quantity,
                    price: this.lastPrice,
                    orderId: order.orderId
                });
            }

            this.position = 'long';
            this.entryPrice = this.lastPrice;
            this.highestPrice = this.lastPrice;
            this.dailyStats.trades++;

            await this.sendTelegramNotification(`‚úÖ COMPRA executada: ${this.config.trading.quantity} ${this.config.trading.symbol} a ${this.lastPrice}`);

            return true;
        } catch (error) {
            this.logger.error('Erro na ordem de compra', { error: error.message });
            return false;
        } finally {
            this.orderInProgress = false;
        }
    }

    // Executar ordem de venda
    async sellOrder(reason = 'Sinal') {
        if (this.orderInProgress) {
            this.logger.warn('Ordem j√° em progresso, ignorando nova ordem de venda');
            return false;
        }

        this.orderInProgress = true;

        try {
            if (this.lastPrice <= 0 || this.entryPrice <= 0) {
                this.logger.warn('Pre√ßos inv√°lidos para venda');
                return false;
            }

            const balance = await this.getBalance();

            if (balance.BTC < this.config.trading.quantity) {
                this.logger.warn('Saldo insuficiente para venda', { 
                    required: this.config.trading.quantity,
                    available: balance.BTC
                });
                return false;
            }

            const profit = ((this.lastPrice - this.entryPrice) / this.entryPrice) * 100;

            // Modo simula√ß√£o
            if (this.config.development.simulateTrading) {
                this.logger.info('üéÆ SIMULA√á√ÉO - Ordem de venda executada', {
                    symbol: this.config.trading.symbol,
                    quantity: this.config.trading.quantity,
                    price: this.lastPrice,
                    reason: reason
                });
            } else {
                const order = await this.authenticatedRequest('POST', '/api/v3/order', {
                    symbol: this.config.trading.symbol,
                    side: 'SELL',
                    type: 'MARKET',
                    quantity: this.config.trading.quantity.toFixed(this.config.advanced.quantityPrecision)
                });

                this.logger.trade('SELL', {
                    symbol: this.config.trading.symbol,
                    quantity: this.config.trading.quantity,
                    price: this.lastPrice,
                    reason: reason,
                    orderId: order.orderId
                });
            }

            this.logger.profit({
                profit: profit,
                entryPrice: this.entryPrice,
                exitPrice: this.lastPrice,
                reason: reason
            });

            this.position = null;
            this.entryPrice = 0;
            this.highestPrice = 0;
            this.dailyStats.profit += profit;

            await this.sendTelegramNotification(`‚úÖ VENDA executada (${reason}): ${this.config.trading.quantity} ${this.config.trading.symbol} a ${this.lastPrice} | Lucro: ${profit.toFixed(2)}%`);

            return true;
        } catch (error) {
            this.logger.error('Erro na ordem de venda', { error: error.message });
            return false;
        } finally {
            this.orderInProgress = false;
        }
    }

    // Verificar condi√ß√µes de sa√≠da (stop loss, take profit, trailing stop)
    checkExitConditions() {
        if (!this.position || this.entryPrice === 0) return null;

        const profitPercent = ((this.lastPrice - this.entryPrice) / this.entryPrice) * 100;

        // Atualizar maior pre√ßo para trailing stop
        if (this.config.riskManagement.trailingStop && this.lastPrice > this.highestPrice) {
            this.highestPrice = this.lastPrice;
        }

        // Stop Loss
        if (profitPercent <= this.config.riskManagement.stopLoss) {
            this.logger.warn(`Stop Loss ativado: ${profitPercent.toFixed(2)}%`);
            return 'Stop Loss';
        }

        // Take Profit
        if (profitPercent >= this.config.riskManagement.takeProfit) {
            this.logger.info(`Take Profit ativado: ${profitPercent.toFixed(2)}%`);
            return 'Take Profit';
        }

        // Trailing Stop
        if (this.config.riskManagement.trailingStop && this.highestPrice > this.entryPrice) {
            const trailingStopPrice = this.highestPrice * (1 - this.config.riskManagement.trailingStopPercent / 100);
            if (this.lastPrice <= trailingStopPrice) {
                this.logger.info(`Trailing Stop ativado: Pre√ßo caiu de ${this.highestPrice} para ${this.lastPrice}`);
                return 'Trailing Stop';
            }
        }

        return null;
    }

    // Processar nova vela/pre√ßo
    async processNewPrice(price) {
        try {
            this.lastPrice = parseFloat(price.toFixed(this.config.advanced.pricePrecision));
            this.prices.push(this.lastPrice);

            if (this.prices.length > 200) this.prices.shift();

            this.calculateMovingAverages();

            // Verificar condi√ß√µes de sa√≠da primeiro
            const exitReason = this.checkExitConditions();
            if (exitReason && this.position === 'long') {
                await this.sellOrder(exitReason);
                return;
            }

            // Verificar novos sinais apenas se n√£o h√° posi√ß√£o aberta e bot est√° inicializado
            if (!this.position && this.isInitialized && !this.orderInProgress) {
                const signal = this.checkSignal();

                if (signal === 'BUY') {
                    this.logger.signal('COMPRA', {
                        symbol: this.config.trading.symbol,
                        price: this.lastPrice,
                        shortMA: this.shortMA[this.shortMA.length - 1],
                        longMA: this.longMA[this.longMA.length - 1]
                    });
                    await this.buyOrder();
                } else if (signal === 'SELL' && this.position) {
                    this.logger.signal('VENDA', {
                        symbol: this.config.trading.symbol,
                        price: this.lastPrice,
                        shortMA: this.shortMA[this.shortMA.length - 1],
                        longMA: this.longMA[this.longMA.length - 1]
                    });
                    await this.sellOrder('Sinal');
                }
            }
        } catch (error) {
            this.logger.error('Erro ao processar novo pre√ßo', { error: error.message });
        }
    }

    // Exibir status atual
    displayStatus() {
        try {
            const currentShortMA = this.shortMA[this.shortMA.length - 1];
            const currentLongMA = this.longMA[this.longMA.length - 1];

            const status = {
                symbol: this.config.trading.symbol,
                currentPrice: this.lastPrice,
                shortPeriod: this.config.trading.shortPeriod,
                longPeriod: this.config.trading.longPeriod,
                shortMA: currentShortMA?.toFixed(2),
                longMA: currentLongMA?.toFixed(2),
                position: this.position,
                entryPrice: this.entryPrice,
                profit: this.position && this.entryPrice > 0 ? ((this.lastPrice - this.entryPrice) / this.entryPrice) * 100 : 0,
                highestPrice: this.highestPrice,
                trailingStop: this.config.riskManagement.trailingStop,
                trailingStopPrice: this.config.riskManagement.trailingStop && this.highestPrice > this.entryPrice 
                    ? this.highestPrice * (1 - this.config.riskManagement.trailingStopPercent / 100) 
                    : 0
            };

            this.logger.status(status);
        } catch (error) {
            this.logger.error('Erro ao exibir status', { error: error.message });
        }
    }

    // Enviar notifica√ß√£o Telegram
    async sendTelegramNotification(message) {
        if (!this.config.notifications.telegram.enabled) return;

        try {
            const { botToken, chatId } = this.config.notifications.telegram;
            await axios.post(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                chat_id: chatId,
                text: `ü§ñ *Trading Bot*\n\n${message}`,
                parse_mode: 'Markdown'
            });
        } catch (error) {
            this.logger.error('Erro ao enviar notifica√ß√£o Telegram', { error: error.message });
        }
    }

    // Conectar ao WebSocket da Binance
    connectWebSocket() {
        try {
            const wsUrl = `${this.config.api.wsURL}/${this.config.trading.symbol.toLowerCase()}@kline_1m`;
            this.ws = new WebSocket(wsUrl);

            this.ws.on('open', () => {
                this.logger.info('üì° Conectado ao WebSocket da Binance');
                this.reconnectAttempts = 0;
                this.setupHeartbeat();
            });

            this.ws.on('message', async (data) => {
                try {
                    const kline = JSON.parse(data);

                    if (kline.k && kline.k.x) { // Vela fechada
                        const closePrice = parseFloat(kline.k.c);
                        await this.processNewPrice(closePrice);
                    }
                } catch (error) {
                    this.logger.error('Erro ao processar mensagem WebSocket', { error: error.message });
                }
            });

            this.ws.on('error', (error) => {
                this.logger.error('Erro no WebSocket', { error: error.message });
            });

            this.ws.on('close', () => {
                this.logger.warn('üîå Conex√£o WebSocket fechada');
                this.clearHeartbeat();
                this.handleReconnection();
            });

        } catch (error) {
            this.logger.error('Erro ao conectar WebSocket', { error: error.message });
            this.handleReconnection();
        }
    }

    // Configurar heartbeat para manter conex√£o
    setupHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.ws.ping();
            }
        }, this.config.advanced.heartbeatInterval);
    }

    // Limpar heartbeat
    clearHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    // Gerenciar reconex√£o
    handleReconnection() {
        if (this.reconnectAttempts >= this.config.advanced.maxReconnectAttempts) {
            this.logger.error('M√°ximo de tentativas de reconex√£o atingido. Parando o bot.');
            process.exit(1);
        }

        this.reconnectAttempts++;
        const delay = Math.min(5000 * this.reconnectAttempts, 30000);

        this.logger.info(`Tentativa de reconex√£o ${this.reconnectAttempts}/${this.config.advanced.maxReconnectAttempts} em ${delay/1000}s`);

        setTimeout(() => {
            this.connectWebSocket();
        }, delay);
    }

    // Reinicializa√ß√£o autom√°tica em caso de erro cr√≠tico
    async handleCriticalError(error) {
        this.logger.error('Erro cr√≠tico detectado', { error: error.message });
        await this.sendTelegramNotification(`‚ö†Ô∏è Erro cr√≠tico: ${error.message}\nTentando reinicializar...`);

        try {
            // Resetar estados
            this.isInitialized = false;
            this.orderInProgress = false;

            // Fechar conex√µes
            if (this.ws) {
                this.ws.close();
            }
            this.clearHeartbeat();

            // Aguardar e tentar reinicializar
            await this.sleep(5000);
            await this.init();
        } catch (reinitError) {
            this.logger.error('Falha na reinicializa√ß√£o', { error: reinitError.message });
            process.exit(1);
        }
    }

    // Inicializar bot
    async init() {
        try {
            this.logger.startup(this.config);

            // Verificar se arquivo .env existe
            if (!this.config.api.apiKey || this.config.api.apiKey === 'sua_api_key_aqui') {
                throw new Error('Configure suas credenciais da API Binance no arquivo .env');
            }

            await this.getHistoricalData();

            const balance = await this.getBalance();
            this.logger.info(`Saldo inicial obtido`, { balance });

            this.connectWebSocket();

            // Status peri√≥dico
            this.statusInterval = setInterval(() => {
                if (this.lastPrice > 0) {
                    this.displayStatus();
                }
            }, this.config.advanced.statusDisplayInterval);

            // Limpeza de logs
            this.logger.cleanup();

            // Notifica√ß√£o de in√≠cio
            await this.sendTelegramNotification('üöÄ Bot de Trading iniciado com sucesso!');

        } catch (error) {
            this.logger.error('Erro na inicializa√ß√£o', { error: error.message });
            await this.handleCriticalError(error);
        }
    }

    // Parar bot graciosamente
    async stop() {
        this.logger.info('üõë Parando o bot...');

        // Limpar intervalos
        if (this.statusInterval) {
            clearInterval(this.statusInterval);
        }
        this.clearHeartbeat();

        // Fechar WebSocket
        if (this.ws) {
            this.ws.close();
        }

        // Relat√≥rio final
        this.logger.info('Relat√≥rio final', {
            dailyTrades: this.dailyStats.trades,
            dailyProfit: this.dailyStats.profit,
            currentPosition: this.position
        });

        await this.sendTelegramNotification('üõë Bot de Trading parado');
        process.exit(0);
    }
}

// Verificar se o arquivo .env existe
const ConfigManager = require('./config/ConfigManager');
if (!require('fs').existsSync('.env')) {
    console.log('‚ö†Ô∏è  Arquivo .env n√£o encontrado. Criando arquivo de exemplo...');
    ConfigManager.createExampleEnv();
    console.log('üìù Configure suas credenciais no arquivo .env antes de executar o bot novamente.');
    process.exit(1);
}

// Configura√ß√£o e inicializa√ß√£o
const bot = new BinanceTradingBot();

// Tratamento de sinais do sistema
process.on('SIGINT', () => bot.stop());
process.on('SIGTERM', () => bot.stop());

// Tratamento de erros n√£o capturados
process.on('uncaughtException', async (error) => {
    console.error('Erro n√£o capturado:', error);
    await bot.handleCriticalError(error);
});

process.on('unhandledRejection', async (reason, promise) => {
    console.error('Promise rejeitada:', reason);
    await bot.handleCriticalError(new Error(`Promise rejeitada: ${reason}`));
});

module.exports = BinanceTradingBot;

// arquivo setup.js

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

console.log('üöÄ Configura√ß√£o do Bot de Trading BTC\n');

async function question(prompt) {
    return new Promise((resolve) => {
        rl.question(prompt, resolve);
    });
}

async function setup() {
    try {
        // Verificar se .env j√° existe
        if (fs.existsSync('.env')) {
            const overwrite = await question('Arquivo .env j√° existe. Deseja sobrescrever? (y/N): ');
            if (overwrite.toLowerCase() !== 'y') {
                console.log('Setup cancelado.');
                process.exit(0);
            }
        }

        console.log('\n=== CONFIGURA√á√ïES DA API BINANCE ===');
        const apiKey = await question('API Key da Binance: ');
        const apiSecret = await question('API Secret da Binance: ');

        console.log('\n=== CONFIGURA√á√ïES DE TRADING ===');
        const symbol = await question('S√≠mbolo (padr√£o: BTCUSDT): ') || 'BTCUSDT';
        const quantity = await question('Quantidade por trade (padr√£o: 0.001): ') || '0.001';
        const shortPeriod = await question('Per√≠odo da m√©dia m√≥vel curta (padr√£o: 7): ') || '7';
        const longPeriod = await question('Per√≠odo da m√©dia m√≥vel longa (padr√£o: 21): ') || '21';
        const useEMA = await question('Usar EMA em vez de SMA? (Y/n): ');

        console.log('\n=== GERENCIAMENTO DE RISCO ===');
        const stopLoss = await question('Stop Loss em % (padr√£o: -2.0): ') || '-2.0';
        const takeProfit = await question('Take Profit em % (padr√£o: 3.0): ') || '3.0';
        const trailingStop = await question('Ativar Trailing Stop? (Y/n): ');
        const trailingStopPercent = await question('Trailing Stop % (padr√£o: 1.5): ') || '1.5';

        console.log('\n=== NOTIFICA√á√ïES TELEGRAM (OPCIONAL) ===');
        const telegramEnabled = await question('Ativar notifica√ß√µes Telegram? (y/N): ');
        let telegramBotToken = '';
        let telegramChatId = '';

        if (telegramEnabled.toLowerCase() === 'y') {
            telegramBotToken = await question('Bot Token do Telegram: ');
            telegramChatId = await question('Chat ID do Telegram: ');
        }

        console.log('\n=== CONFIGURA√á√ïES AVAN√áADAS ===');
        const logLevel = await question('N√≠vel de log (debug/info/warn/error - padr√£o: info): ') || 'info';
        const simulateTrading = await question('Modo simula√ß√£o (sem trades reais)? (y/N): ');

        // Criar conte√∫do do .env
        const envContent = `# ===========================================
# CONFIGURA√á√ïES DA API BINANCE
# ===========================================
BINANCE_API_KEY=${apiKey}
BINANCE_API_SECRET=${apiSecret}
BINANCE_BASE_URL=https://api.binance.com
BINANCE_WS_URL=wss://stream.binance.com:9443/ws

# ===========================================
# CONFIGURA√á√ïES DE TRADING
# ===========================================
TRADING_SYMBOL=${symbol}
TRADING_QUANTITY=${quantity}
TRADING_SHORT_PERIOD=${shortPeriod}
TRADING_LONG_PERIOD=${longPeriod}
TRADING_USE_EMA=${useEMA.toLowerCase() !== 'n'}
TRADING_MIN_PROFIT=0.5

# ===========================================
# GERENCIAMENTO DE RISCO
# ===========================================
RISK_STOP_LOSS=${stopLoss}
RISK_TAKE_PROFIT=${takeProfit}
RISK_TRAILING_STOP=${trailingStop.toLowerCase() !== 'n'}
RISK_TRAILING_STOP_PERCENT=${trailingStopPercent}
RISK_MAX_POSITIONS=1
RISK_MAX_DAILY_LOSS=-5.0
RISK_MAX_DAILY_TRADES=10

# ===========================================
# NOTIFICA√á√ïES TELEGRAM
# ===========================================
TELEGRAM_ENABLED=${telegramEnabled.toLowerCase() === 'y'}
TELEGRAM_BOT_TOKEN=${telegramBotToken}
TELEGRAM_CHAT_ID=${telegramChatId}

# ===========================================
# CONFIGURA√á√ïES DE LOG
# ===========================================
LOG_LEVEL=${logLevel}
LOG_SAVE_TO_FILE=true
LOG_MAX_FILE_SIZE=10
LOG_DIRECTORY=./logs

# ===========================================
# CONFIGURA√á√ïES AVAN√áADAS
# ===========================================
MAX_RECONNECT_ATTEMPTS=10
HEARTBEAT_INTERVAL=30000
STATUS_DISPLAY_INTERVAL=60000
PRICE_PRECISION=8
QUANTITY_PRECISION=6

# ===========================================
# MODO DE DESENVOLVIMENTO
# ===========================================
NODE_ENV=production
DEBUG=false
SIMULATE_TRADING=${simulateTrading.toLowerCase() === 'y'}`;

        // Salvar arquivo .env
        fs.writeFileSync('.env', envContent);

        // Criar diret√≥rios necess√°rios
        const dirs = ['logs', 'src/config', 'src/utils', 'scripts', 'tests'];
        dirs.forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });

        console.log('\n‚úÖ Configura√ß√£o conclu√≠da com sucesso!');
        console.log('\nüìÅ Arquivos criados:');
        console.log('   - .env (configura√ß√µes)');
        console.log('   - logs/ (diret√≥rio de logs)');
        
        console.log('\nüöÄ Para iniciar o bot:');
        console.log('   npm start');
        
        console.log('\nüéÆ Para modo simula√ß√£o:');
        console.log('   npm run simulate');
        
        console.log('\nüìä Para ver logs em tempo real:');
        console.log('   npm run logs');

        if (simulateTrading.toLowerCase() === 'y') {
            console.log('\n‚ö†Ô∏è  MODO SIMULA√á√ÉO ATIVADO - Nenhuma ordem real ser√° executada');
        }

        console.log('\n‚ö†Ô∏è  IMPORTANTE:');
        console.log('   - Certifique-se de que suas credenciais da Binance est√£o corretas');
        console.log('   - Teste primeiro em modo simula√ß√£o');
        console.log('   - Use apenas valores que voc√™ pode perder');
        console.log('   - Monitore o bot regularmente');

    } catch (error) {
        console.error('\n‚ùå Erro durante a configura√ß√£o:', error.message);
        process.exit(1);
    } finally {
        rl.close();
    }
}

// Executar setup
setup();

// arquivo configManager.js

const fs = require('fs');
const path = require('path');
require('dotenv').config();

class ConfigManager {
    constructor() {
        this.config = this.loadConfiguration();
        this.validateConfiguration();
    }

    loadConfiguration() {
        const config = {
            // Configura√ß√µes da API
            api: {
                apiKey: process.env.BINANCE_API_KEY,
                apiSecret: process.env.BINANCE_API_SECRET,
                baseURL: process.env.BINANCE_BASE_URL || 'https://api.binance.com',
                wsURL: process.env.BINANCE_WS_URL || 'wss://stream.binance.com:9443/ws'
            },

            // Configura√ß√µes de Trading
            trading: {
                symbol: process.env.TRADING_SYMBOL || 'BTCUSDT',
                quantity: parseFloat(process.env.TRADING_QUANTITY) || 0.001,
                shortPeriod: parseInt(process.env.TRADING_SHORT_PERIOD) || 7,
                longPeriod: parseInt(process.env.TRADING_LONG_PERIOD) || 21,
                useEMA: process.env.TRADING_USE_EMA === 'true',
                minProfit: parseFloat(process.env.TRADING_MIN_PROFIT) || 0.5
            },

            // Gerenciamento de Risco
            riskManagement: {
                stopLoss: parseFloat(process.env.RISK_STOP_LOSS) || -2.0,
                takeProfit: parseFloat(process.env.RISK_TAKE_PROFIT) || 3.0,
                trailingStop: process.env.RISK_TRAILING_STOP === 'true',
                trailingStopPercent: parseFloat(process.env.RISK_TRAILING_STOP_PERCENT) || 1.5,
                maxPositions: parseInt(process.env.RISK_MAX_POSITIONS) || 1,
                maxDailyLoss: parseFloat(process.env.RISK_MAX_DAILY_LOSS) || -5.0,
                maxDailyTrades: parseInt(process.env.RISK_MAX_DAILY_TRADES) || 10
            },

            // Notifica√ß√µes
            notifications: {
                telegram: {
                    enabled: process.env.TELEGRAM_ENABLED === 'true',
                    botToken: process.env.TELEGRAM_BOT_TOKEN || '',
                    chatId: process.env.TELEGRAM_CHAT_ID || ''
                }
            },

            // Configura√ß√µes de Log
            logging: {
                level: process.env.LOG_LEVEL || 'info',
                saveToFile: process.env.LOG_SAVE_TO_FILE === 'true',
                maxFileSize: parseInt(process.env.LOG_MAX_FILE_SIZE) || 10,
                directory: process.env.LOG_DIRECTORY || './logs'
            },

            // Configura√ß√µes Avan√ßadas
            advanced: {
                maxReconnectAttempts: parseInt(process.env.MAX_RECONNECT_ATTEMPTS) || 10,
                heartbeatInterval: parseInt(process.env.HEARTBEAT_INTERVAL) || 30000,
                statusDisplayInterval: parseInt(process.env.STATUS_DISPLAY_INTERVAL) || 60000,
                pricePrecision: parseInt(process.env.PRICE_PRECISION) || 8,
                quantityPrecision: parseInt(process.env.QUANTITY_PRECISION) || 6
            },

            // Configura√ß√µes de Desenvolvimento
            development: {
                nodeEnv: process.env.NODE_ENV || 'production',
                debug: process.env.DEBUG === 'true',
                simulateTrading: process.env.SIMULATE_TRADING === 'true'
            }
        };

        return config;
    }

    validateConfiguration() {
        const errors = [];

        // Validar credenciais da API
        if (!this.config.api.apiKey || this.config.api.apiKey === 'sua_api_key_aqui') {
            errors.push('BINANCE_API_KEY n√£o configurada ou inv√°lida');
        }

        if (!this.config.api.apiSecret || this.config.api.apiSecret === 'sua_api_secret_aqui') {
            errors.push('BINANCE_API_SECRET n√£o configurada ou inv√°lida');
        }

        // Validar par√¢metros de trading
        if (this.config.trading.quantity <= 0) {
            errors.push('TRADING_QUANTITY deve ser maior que 0');
        }

        if (this.config.trading.shortPeriod >= this.config.trading.longPeriod) {
            errors.push('TRADING_SHORT_PERIOD deve ser menor que TRADING_LONG_PERIOD');
        }

        // Validar par√¢metros de risco
        if (this.config.riskManagement.stopLoss >= 0) {
            errors.push('RISK_STOP_LOSS deve ser negativo');
        }

        if (this.config.riskManagement.takeProfit <= 0) {
            errors.push('RISK_TAKE_PROFIT deve ser positivo');
        }

        // Validar Telegram se habilitado
        if (this.config.notifications.telegram.enabled) {
            if (!this.config.notifications.telegram.botToken) {
                errors.push('TELEGRAM_BOT_TOKEN √© obrigat√≥rio quando Telegram est√° habilitado');
            }
            if (!this.config.notifications.telegram.chatId) {
                errors.push('TELEGRAM_CHAT_ID √© obrigat√≥rio quando Telegram est√° habilitado');
            }
        }

        if (errors.length > 0) {
            throw new Error(`Erro de configura√ß√£o:\n${errors.join('\n')}`);
        }

        // Criar diret√≥rio de logs se n√£o existir
        if (this.config.logging.saveToFile) {
            this.ensureLogDirectory();
        }
    }

    ensureLogDirectory() {
        const logDir = path.resolve(this.config.logging.directory);
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
    }

    getConfig() {
        return this.config;
    }

    // Getter para configura√ß√µes espec√≠ficas
    getApiConfig() {
        return this.config.api;
    }

    getTradingConfig() {
        return this.config.trading;
    }

    getRiskConfig() {
        return this.config.riskManagement;
    }

    getNotificationConfig() {
        return this.config.notifications;
    }

    getLoggingConfig() {
        return this.config.logging;
    }

    getAdvancedConfig() {
        return this.config.advanced;
    }

    getDevelopmentConfig() {
        return this.config.development;
    }

    // M√©todo para exibir configura√ß√£o (sem dados sens√≠veis)
    displayConfig() {
        const safeConfig = JSON.parse(JSON.stringify(this.config));
        
        // Ocultar dados sens√≠veis
        safeConfig.api.apiKey = this.maskSensitiveData(safeConfig.api.apiKey);
        safeConfig.api.apiSecret = this.maskSensitiveData(safeConfig.api.apiSecret);
        
        if (safeConfig.notifications.telegram.botToken) {
            safeConfig.notifications.telegram.botToken = this.maskSensitiveData(safeConfig.notifications.telegram.botToken);
        }

        return safeConfig;
    }

    maskSensitiveData(data) {
        if (!data || data.length < 8) return '***';
        return data.substring(0, 4) + '*'.repeat(data.length - 8) + data.substring(data.length - 4);
    }

    // M√©todo para salvar configura√ß√£o de exemplo
    static createExampleEnv() {
        const exampleEnv = `# ===========================================
# CONFIGURA√á√ïES DA API BINANCE
# ===========================================
BINANCE_API_KEY=sua_api_key_aqui
BINANCE_API_SECRET=sua_api_secret_aqui
BINANCE_BASE_URL=https://api.binance.com
BINANCE_WS_URL=wss://stream.binance.com:9443/ws

# ===========================================
# CONFIGURA√á√ïES DE TRADING
# ===========================================
TRADING_SYMBOL=BTCUSDT
TRADING_QUANTITY=0.001
TRADING_SHORT_PERIOD=7
TRADING_LONG_PERIOD=21
TRADING_USE_EMA=true
TRADING_MIN_PROFIT=0.5

# ===========================================
# GERENCIAMENTO DE RISCO
# ===========================================
RISK_STOP_LOSS=-2.0
RISK_TAKE_PROFIT=3.0
RISK_TRAILING_STOP=true
RISK_TRAILING_STOP_PERCENT=1.5
RISK_MAX_POSITIONS=1
RISK_MAX_DAILY_LOSS=-5.0
RISK_MAX_DAILY_TRADES=10

# ===========================================
# NOTIFICA√á√ïES TELEGRAM
# ===========================================
TELEGRAM_ENABLED=false
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=

# ===========================================
# CONFIGURA√á√ïES DE LOG
# ===========================================
LOG_LEVEL=info
LOG_SAVE_TO_FILE=true
LOG_MAX_FILE_SIZE=10
LOG_DIRECTORY=./logs

# ===========================================
# CONFIGURA√á√ïES AVAN√áADAS
# ===========================================
MAX_RECONNECT_ATTEMPTS=10
HEARTBEAT_INTERVAL=30000
STATUS_DISPLAY_INTERVAL=60000
PRICE_PRECISION=8
QUANTITY_PRECISION=6

# ===========================================
# MODO DE DESENVOLVIMENTO
# ===========================================
NODE_ENV=production
DEBUG=false
SIMULATE_TRADING=false`;

        const envPath = path.resolve('.env');
        if (!fs.existsSync(envPath)) {
            fs.writeFileSync(envPath, exampleEnv);
            console.log('‚úÖ Arquivo .env criado com configura√ß√µes de exemplo');
            console.log('üìù Configure suas credenciais da API Binance no arquivo .env');
            return true;
        }
        return false;
    }
}

module.exports = ConfigManager;

// arquivo Logger.js

const fs = require('fs');
const path = require('path');
require('dotenv').config();

class ConfigManager {
    constructor() {
        this.config = this.loadConfiguration();
        this.validateConfiguration();
    }

    loadConfiguration() {
        const config = {
            // Configura√ß√µes da API
            api: {
                apiKey: process.env.BINANCE_API_KEY,
                apiSecret: process.env.BINANCE_API_SECRET,
                baseURL: process.env.BINANCE_BASE_URL || 'https://api.binance.com',
                wsURL: process.env.BINANCE_WS_URL || 'wss://stream.binance.com:9443/ws'
            },

            // Configura√ß√µes de Trading
            trading: {
                symbol: process.env.TRADING_SYMBOL || 'BTCUSDT',
                quantity: parseFloat(process.env.TRADING_QUANTITY) || 0.001,
                shortPeriod: parseInt(process.env.TRADING_SHORT_PERIOD) || 7,
                longPeriod: parseInt(process.env.TRADING_LONG_PERIOD) || 21,
                useEMA: process.env.TRADING_USE_EMA === 'true',
                minProfit: parseFloat(process.env.TRADING_MIN_PROFIT) || 0.5
            },

            // Gerenciamento de Risco
            riskManagement: {
                stopLoss: parseFloat(process.env.RISK_STOP_LOSS) || -2.0,
                takeProfit: parseFloat(process.env.RISK_TAKE_PROFIT) || 3.0,
                trailingStop: process.env.RISK_TRAILING_STOP === 'true',
                trailingStopPercent: parseFloat(process.env.RISK_TRAILING_STOP_PERCENT) || 1.5,
                maxPositions: parseInt(process.env.RISK_MAX_POSITIONS) || 1,
                maxDailyLoss: parseFloat(process.env.RISK_MAX_DAILY_LOSS) || -5.0,
                maxDailyTrades: parseInt(process.env.RISK_MAX_DAILY_TRADES) || 10
            },

            // Notifica√ß√µes
            notifications: {
                telegram: {
                    enabled: process.env.TELEGRAM_ENABLED === 'true',
                    botToken: process.env.TELEGRAM_BOT_TOKEN || '',
                    chatId: process.env.TELEGRAM_CHAT_ID || ''
                }
            },

            // Configura√ß√µes de Log
            logging: {
                level: process.env.LOG_LEVEL || 'info',
                saveToFile: process.env.LOG_SAVE_TO_FILE === 'true',
                maxFileSize: parseInt(process.env.LOG_MAX_FILE_SIZE) || 10,
                directory: process.env.LOG_DIRECTORY || './logs'
            },

            // Configura√ß√µes Avan√ßadas
            advanced: {
                maxReconnectAttempts: parseInt(process.env.MAX_RECONNECT_ATTEMPTS) || 10,
                heartbeatInterval: parseInt(process.env.HEARTBEAT_INTERVAL) || 30000,
                statusDisplayInterval: parseInt(process.env.STATUS_DISPLAY_INTERVAL) || 60000,
                pricePrecision: parseInt(process.env.PRICE_PRECISION) || 8,
                quantityPrecision: parseInt(process.env.QUANTITY_PRECISION) || 6
            },

            // Configura√ß√µes de Desenvolvimento
            development: {
                nodeEnv: process.env.NODE_ENV || 'production',
                debug: process.env.DEBUG === 'true',
                simulateTrading: process.env.SIMULATE_TRADING === 'true'
            }
        };

        return config;
    }

    validateConfiguration() {
        const errors = [];

        // Validar credenciais da API
        if (!this.config.api.apiKey || this.config.api.apiKey === 'sua_api_key_aqui') {
            errors.push('BINANCE_API_KEY n√£o configurada ou inv√°lida');
        }

        if (!this.config.api.apiSecret || this.config.api.apiSecret === 'sua_api_secret_aqui') {
            errors.push('BINANCE_API_SECRET n√£o configurada ou inv√°lida');
        }

        // Validar par√¢metros de trading
        if (this.config.trading.quantity <= 0) {
            errors.push('TRADING_QUANTITY deve ser maior que 0');
        }

        if (this.config.trading.shortPeriod >= this.config.trading.longPeriod) {
            errors.push('TRADING_SHORT_PERIOD deve ser menor que TRADING_LONG_PERIOD');
        }

        // Validar par√¢metros de risco
        if (this.config.riskManagement.stopLoss >= 0) {
            errors.push('RISK_STOP_LOSS deve ser negativo');
        }

        if (this.config.riskManagement.takeProfit <= 0) {
            errors.push('RISK_TAKE_PROFIT deve ser positivo');
        }

        // Validar Telegram se habilitado
        if (this.config.notifications.telegram.enabled) {
            if (!this.config.notifications.telegram.botToken) {
                errors.push('TELEGRAM_BOT_TOKEN √© obrigat√≥rio quando Telegram est√° habilitado');
            }
            if (!this.config.notifications.telegram.chatId) {
                errors.push('TELEGRAM_CHAT_ID √© obrigat√≥rio quando Telegram est√° habilitado');
            }
        }

        if (errors.length > 0) {
            throw new Error(`Erro de configura√ß√£o:\n${errors.join('\n')}`);
        }

        // Criar diret√≥rio de logs se n√£o existir
        if (this.config.logging.saveToFile) {
            this.ensureLogDirectory();
        }
    }

    ensureLogDirectory() {
        const logDir = path.resolve(this.config.logging.directory);
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
    }

    getConfig() {
        return this.config;
    }

    // Getter para configura√ß√µes espec√≠ficas
    getApiConfig() {
        return this.config.api;
    }

    getTradingConfig() {
        return this.config.trading;
    }

    getRiskConfig() {
        return this.config.riskManagement;
    }

    getNotificationConfig() {
        return this.config.notifications;
    }

    getLoggingConfig() {
        return this.config.logging;
    }

    getAdvancedConfig() {
        return this.config.advanced;
    }

    getDevelopmentConfig() {
        return this.config.development;
    }

    // M√©todo para exibir configura√ß√£o (sem dados sens√≠veis)
    displayConfig() {
        const safeConfig = JSON.parse(JSON.stringify(this.config));
        
        // Ocultar dados sens√≠veis
        safeConfig.api.apiKey = this.maskSensitiveData(safeConfig.api.apiKey);
        safeConfig.api.apiSecret = this.maskSensitiveData(safeConfig.api.apiSecret);
        
        if (safeConfig.notifications.telegram.botToken) {
            safeConfig.notifications.telegram.botToken = this.maskSensitiveData(safeConfig.notifications.telegram.botToken);
        }

        return safeConfig;
    }

    maskSensitiveData(data) {
        if (!data || data.length < 8) return '***';
        return data.substring(0, 4) + '*'.repeat(data.length - 8) + data.substring(data.length - 4);
    }

    // M√©todo para salvar configura√ß√£o de exemplo
    static createExampleEnv() {
        const exampleEnv = `# ===========================================
# CONFIGURA√á√ïES DA API BINANCE
# ===========================================
BINANCE_API_KEY=sua_api_key_aqui
BINANCE_API_SECRET=sua_api_secret_aqui
BINANCE_BASE_URL=https://api.binance.com
BINANCE_WS_URL=wss://stream.binance.com:9443/ws

# ===========================================
# CONFIGURA√á√ïES DE TRADING
# ===========================================
TRADING_SYMBOL=BTCUSDT
TRADING_QUANTITY=0.001
TRADING_SHORT_PERIOD=7
TRADING_LONG_PERIOD=21
TRADING_USE_EMA=true
TRADING_MIN_PROFIT=0.5

# ===========================================
# GERENCIAMENTO DE RISCO
# ===========================================
RISK_STOP_LOSS=-2.0
RISK_TAKE_PROFIT=3.0
RISK_TRAILING_STOP=true
RISK_TRAILING_STOP_PERCENT=1.5
RISK_MAX_POSITIONS=1
RISK_MAX_DAILY_LOSS=-5.0
RISK_MAX_DAILY_TRADES=10

# ===========================================
# NOTIFICA√á√ïES TELEGRAM
# ===========================================
TELEGRAM_ENABLED=false
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=

# ===========================================
# CONFIGURA√á√ïES DE LOG
# ===========================================
LOG_LEVEL=info
LOG_SAVE_TO_FILE=true
LOG_MAX_FILE_SIZE=10
LOG_DIRECTORY=./logs

# ===========================================
# CONFIGURA√á√ïES AVAN√áADAS
# ===========================================
MAX_RECONNECT_ATTEMPTS=10
HEARTBEAT_INTERVAL=30000
STATUS_DISPLAY_INTERVAL=60000
PRICE_PRECISION=8
QUANTITY_PRECISION=6

# ===========================================
# MODO DE DESENVOLVIMENTO
# ===========================================
NODE_ENV=production
DEBUG=false
SIMULATE_TRADING=false`;

        const envPath = path.resolve('.env');
        if (!fs.existsSync(envPath)) {
            fs.writeFileSync(envPath, exampleEnv);
            console.log('‚úÖ Arquivo .env criado com configura√ß√µes de exemplo');
            console.log('üìù Configure suas credenciais da API Binance no arquivo .env');
            return true;
        }
        return false;
    }
}

module.exports = ConfigManager;